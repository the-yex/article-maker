> 给变量一个「门牌号」，让程序找到它真正的家。

如果你是从 Python、Java 或 Ruby 转战 Go 的开发者，第一次看到 `&` 和 `*` 这两个符号时，心里是不是咯噔一下？

指针 —— 这个在不少语言里被隐藏起来的概念，在 Go 里却需要你直面它。

别慌。今天我用最简单的比喻和三张核心图，带你彻底搞懂 Go 指针。**你会发现，它其实简单得超乎想象。**

## 一、内存：计算机的“储物柜大楼”

想象一下，计算机的内存就像一幢巨大的储物柜大楼。

每个储物柜都有唯一的编号：1号柜、2号柜、3号柜……这些编号就是**内存地址**。

每个储物柜里只能放**一件东西**（一个值）。

![](https://www.helloimg.com/i/2026/01/04/6959d9a3af8be.png)

计算机做的所有事情，本质上就是：

1. 根据地址找到对应的储物柜（读取）
2. 把东西放进指定的储物柜（写入）

## 二、变量：给储物柜贴上的“便利贴”

早期编程，程序员得自己记着：「200号柜放用户年龄，201号柜放计算结果……」

这太痛苦了！于是「变量」诞生了。

**变量，就是给储物柜贴上的便利贴标签。**

你不用再记住「200号柜」，只需记住「这个柜子叫 `age`」。

程序从这样：

> “取出200号柜的东西，乘以3，放进201号柜”

变成了这样：

> “取出 `a` 柜的东西，乘以3，放进 `b` 柜”

![](https://www.helloimg.com/i/2026/01/04/6959db3395dd6.png)

用 Go 写，就是两行清爽的代码：

``````go
a := 6
b := a * 3
``````

编译器在背后默默帮你分配柜子、贴标签、管理空间==**你解放了。**

## 三、指针：写着“另一个柜子地址”的纸条

现在问题来了：如果我想让多个便利贴指向同一个柜子，怎么办？

这就是指针出场的时候。

**指针，是一张特殊的纸条，上面写的不是值，而是「另一个储物柜的地址」。**

来看这段关键代码：

``````go
func main() {
    a := 200      // 在某个柜子贴上标签a，里面放200
    b := &a       // b是一张纸条，写着“a柜的地址”
    *b++          // 找到b纸条指向的柜子，把里面的值+1
    fmt.Println(a) // 输出：201
}
``````

让我用三张图，把整个过程画给你看：

### 第一步：创建变量 `a`

![](https://www.helloimg.com/i/2026/01/04/6959dbad7b848.png)

`a` 是一个便利贴，贴在某号柜子上，里面放着值 `200`。

### 第二步：创建指针 `b`

![](https://www.helloimg.com/i/2026/01/04/6959dbf0db0ca.png)
`b` 是另一张便利贴，但它很特殊 —— 上面写的是：「`a` 柜的地址」。  

`&a` 就是「给我 `a` 的地址」的意思。

### 第三步：通过指针修改值

![](https://www.helloimg.com/i/2026/01/04/6959df3266ae6.png)
`*b` 操作叫「解引用」，意思是：

**「别看我这张纸条，去看我纸条上写的那个地址对应的柜子！」**

所以 `*b++` 就是：「找到 `b` 纸条指向的柜子，把里面的值加1」。

### 第四步：结果验证


![](https://www.helloimg.com/i/2026/01/04/6959df2c9efe1.png)
最后 `a` 的值自然变成了 `201`。

因为 `a` 和 `*b` 指向的是同一个柜子！

## 为什么 Go 需要指针？

你可能想问：既然有变量了，为什么还要指针？

1. **性能**：传递大的结构体时，传指针（一个地址）比传整个值快得多
2. **修改**：函数内部想修改外部变量，必须传指针
3. **共享**：多个地方需要操作同一份数据时

## 总结

**指针，就是「地址的便利贴」。**

它不存储实际的值，只存储「值在哪里」这个信息。

`&` 是「取地址符」（给我这个柜子的地址）
`*` 是「解引用符」（带我去这个地址指向的柜子）