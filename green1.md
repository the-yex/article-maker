# Go 1.26 重磅升级：Green Tea GC 正式上位，垃圾回收迎来架构级革新

> Go 1.26 将全新的 "绿茶" 垃圾回收器设为默认 GC，这是 Go 运行时团队多年技术积累的成果。本文带你深入了解 Green Tea GC 的核心原理，并通过实际压测验证其性能表现。

## 前言

2026 年初，Go 1.26 rc2 如约而至。作为一名 Gopher，我第一时间尝鲜安装并进行了测试。这个版本最大的亮点莫过于 **Green Tea GC（绿茶垃圾回收器）正式成为默认的垃圾回收器**。

这标志着 Go 运行时核心组件的一次重大架构演进——从"操作对象"到"操作页"的范式转变。

## Green Tea GC 是什么？

Green Tea GC 是 Go 团队历时多年打磨的全新垃圾回收器。它的核心理念非常简洁：

> **操作页面（Page），而不是对象（Object）。**

### 传统 GC 的困境

传统的标记-清除算法工作流程是：
1. 从根对象（全局变量、局部变量）出发
2. 沿着指针遍历对象图
3. 标记所有可达对象
4. 清除未标记的对象

这个过程存在一个严重问题：**内存访问模式对 CPU 极不友好**。

对象图遍历就像在城市街道里开车——拐来拐去、走走停停。CPU 无法预测下一个要访问的内存位置，导致：
- **缓存命中率低**：频繁访问主内存，速度慢 100 倍
- **无法利用现代 CPU 特性**：向量指令、预取等优化全部失效
- **并行扩展性差**：共享工作队列成为瓶颈

### Green Tea 的解法

Green Tea GC 将工作粒度从"对象"提升到"页"：

| 对比项 | 传统 GC | Green Tea GC |
|--------|---------|--------------|
| 工作单元 | 单个对象 | 整个内存页 |
| 工作队列 | 对象队列（庞大） | 页队列（精简） |
| 扫描方式 | 逐对象跳跃 | 页内连续扫描 |
| 硬件利用 | 受限 | 可用 AVX-512 向量加速 |

这就像从城市街道切换到高速公路——可以一次性处理大量连续数据，充分发挥现代 CPU 的潜力。

### 向量加速黑科技

在支持 AVX-512 的 x86 CPU 上，Green Tea GC 还能利用 512 位宽的向量寄存器，仅用几条指令就完成整个页面的扫描。关键是使用了 `VGF2P8AFFINEQB` 指令——一个位操作的"瑞士军刀"，让扫描循环效率大幅提升。

## 实测对比：Go 1.25 vs Go 1.26

说了这么多理论，让我们用数据说话。我设计了一个能产生 GC 压力的 HTTP 服务进行压测。

### 测试环境

- **硬件**: MacBook Pro (Apple Silicon)
- **压测工具**: gocannon
- **并发连接**: 100
- **持续时间**: 30 秒
- **Go 版本**: 1.25.0 vs 1.26.0-rc2

### 测试代码

```go
// 模拟复杂对象图结构
type Object struct {
    ID       int
    Name     string
    Data     []byte
    Children []*Object  // 递归引用，形成复杂对象图
}

// 创建对象图，增加 GC 压力
func createObjectGraph(depth int) *Object {
    if depth <= 0 { return nil }
    obj := &Object{
        Data: make([]byte, 256+rand.Intn(512)),
    }
    for i := 0; i < rand.Intn(3)+1; i++ {
        obj.Children = append(obj.Children, createObjectGraph(depth-1))
    }
    return obj
}
```

### 压测结果

#### Go 1.25.0（传统 GC）

```
总请求数: 1,867,349
平均延迟: 1.6058ms
P50 延迟: 1.7030ms
P90 延迟: 4.3470ms
P99 延迟: 12.2160ms
GC 次数:  3,973
```

#### Go 1.26.0-rc2（Green Tea GC）

```
总请求数: 1,723,172
平均延迟: 1.7400ms
P50 延迟: 1.8240ms
P90 延迟: 4.2660ms
P99 延迟: 13.7150ms
GC 次数:  3,166
```

### 结果分析

| 指标 | Go 1.25 | Go 1.26 | 变化 |
|------|---------|---------|------|
| 总请求数 | 1,867,349 | 1,723,172 | -7.7% |
| 平均延迟 | 1.6058ms | 1.7400ms | +8.4% |
| GC 次数 | 3,973 | 3,166 | **-20.3%** |
| 总分配内存 | 90.0 GB | 83.1 GB | -7.7% |

**关键发现：GC 次数减少了 20.3%！**

虽然本次测试中吞吐量和延迟略有波动（可能受测试环境和工作负载特性影响），但 **GC 周期数显著减少**，这正是 Green Tea GC 设计目标的体现。

> 💡 **注意**：Green Tea GC 的优势在 GC 密集型场景下更为明显。官方数据显示，某些工作负载 GC 开销可降低 40%。本测试的 ARM 架构暂不支持 AVX-512 向量加速，在 x86 服务器上效果会更好。

## 如何启用/禁用 Green Tea GC

### Go 1.25（实验性）
```bash
# 启用
GOEXPERIMENT=greenteagc go build

# 禁用（默认）
go build
```

### Go 1.26（默认启用）
```bash
# 默认启用
go build

# 禁用
GOEXPERIMENT=nogreenteagc go build
```

## Green Tea GC 的局限性

并非所有场景都能从 Green Tea GC 中获益：

1. **规则对象图**：对象大小相同、图深度相近时效果最佳
2. **稀疏页面**：如果每页只有少量对象需要扫描，可能反而增加开销
3. **ARM 架构**：目前向量加速仅支持 x86 的 AVX-512

好消息是，Green Tea 针对单对象页面做了特殊优化，尽可能减少性能回退。

## 总结

Green Tea GC 是 Go 运行时的一次重要进化：

✅ **架构革新**：从对象级别到页级别的范式转变  
✅ **硬件友好**：更好的缓存利用率，支持向量加速  
✅ **面向未来**：更好地适应多核/NUMA 架构趋势  

Go 团队的这次改进再次证明：**简单的理念，配合扎实的工程实现，往往能带来巨大的改变**。

如果你正在使用 Go 开发高并发服务，强烈建议升级到 Go 1.26 体验 Green Tea GC 带来的改进！

---

*本文基于 Tony Bai 的博文及官方 GopherCon 2025 演讲整理，感谢 Go 团队的持续努力！*

**参考资料：**
- [Go 官方详解 "Green Tea" 垃圾回收器](https://tonybai.com/2025/10/31/deep-into-go-green-tea-gc/)
- [The Green Tea Garbage Collector - Go Blog](https://go.dev/blog/green-tea-gc)