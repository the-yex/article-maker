## 从一次线上 HPA 故障，深挖 Go Map 内存不释放的真相

上一篇文章里，我提到一个线上事故：

> **Go 服务的 map 内存怎么都降不下来，**
> **HPA 眼睁睁看着高内存，死活不肯缩容。**

结果文章一发，私信就来了。

不少人跟我说：

> **“这不是很正常吗？谁让你直接存值了，**
> **存指针不就好了？”**

听起来是不是**非常有道理**？

但**如果你真的在生产环境跑过 HPA + 长连接服务**，你会发现——

**事情远没有这么简单。**

---

## **先复盘：那 20 行“罪魁祸首”代码**

还是这段最小复现代码：

``````go
package main

import (
	"fmt"
	"runtime"
)

func printAlloc() {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	fmt.Printf("%d MB\n", m.Alloc/(1024*1024))
}

func main() {
	n := 1_000_000
	m := make(map[int][128]byte)
	printAlloc()

	for i := 0; i < n; i++ {
		m[i] = [128]byte{}
	}
	printAlloc() 

	for i := 0; i < n; i++ {
		delete(m, i)
	}
	runtime.GC()
	printAlloc() 
	runtime.KeepAlive(m)
}

``````

运行结果是这样的：

``````tex
0 MB  // 开始
301 MB  // 高峰
287 MB   // GC后
``````

**连接都断了，map 也删空了，GC 也跑了，**

**内存却死活不回去。**

HPA 一看，逻辑非常清晰：

> “兄弟你内存还这么高，我不敢缩啊。”

## **那我们“听劝”，改用指针试试**

既然大家都说「存指针就好了」，那我们照做：

``````go
m := make(map[int]*[128]byte)

for i := 0; i < n; i++ {
	m[i] = &[128]byte{}
}
``````

运行结果：

``````tex
0 MB   // 开始
176 MB // 高峰
36 MB  // GC后
``````

这下变化就很明显了：

1. **峰值内存明显下降**
2. **GC 后内存回落得很干净**
3. **HPA 终于“看懂了”**

于是很多人就会下一个结论：

> **“你看吧，存指针果然就没问题了。”**

但这个结论，**只对了一半**。

## **真正的分水岭：128 → 129**

我在上一篇文章里其实已经埋了个坑：

> 把 [128]byte 改成 [129]byte,**内存表现会天差地别**

我们现在就来验证.不存指针，**继续存值**，只是把 128 改成 129：

``````go
m := make(map[int][129]byte)

for i := 0; i < n; i++ {
	m[i] = [129]byte{}
}
``````

运行结果：

``````text
0 MB   // 开始
191 MB // 高峰
36 MB  // GC后
``````

你会发现, **效果几乎和“存指针”一模一样。**

## **这不是巧合，而是 Go 的底层设计**

这里就必须讲清楚一个 **Go runtime 里非常关键的分界线**。

### **✅ value ≤ 128 字节**

- value **直接内联存进 bucket**
- bucket 是一整块连续内存
- delete 只是清空 slot
- **bucket 数量永远不减少**

换句话说：

> 高峰期为了容纳数据扩出来的 bucket,会一辈子跟着这个 map

✅ value > 128 字节
	•	bucket 里 只存一个指针
	•	value 本体放在 heap
	•	delete 后，value 本体可被 GC

这就是你看到的现象：

> **129 比 128 回落得多、回落得快**

⚠️ 但注意一个非常容易被忽略的点：

> **bucket 本身，依然不会释放。**

## **所以，“存指针”到底解决了什么？**

它确实解决了一部分问题，但不是全部。

### **它解决了：**
- 大对象内联拷贝（减少拷贝开销）
- value 本体的 GC 回收
- 内存回落“看起来更干净”
### **它没解决的：**
- map bucket 数量
- overflow bucket
- map header
- **HPA 看到的内存基线**

所以我个人一般**不会为了省内存而主动存指针**（除非本身就需要共享或修改）。

因为 Go 团队的这个设计，本身就说明了一点：
> **小对象：存值，性价比更高**
> **大对象：自动转指针**

## **那生产环境到底该怎么解？**

Go Map的设计目标从来就不是"内存友好"，而是一个工程化的取舍

> **扩容不可逆，缩容交给你自己。**

如果你的服务是：

- 长连接
- 会话状态
- 高峰 / 低谷非常明显

那你**唯一可靠的手段**只有一个：

> **通过 map 替换，让旧 map 整体失去引用**

至于怎么替换（分代、分片、批量重建），

必须结合具体业务设计，这里就不展开了。

## **回到那个“杠点”**

> 「你直接存指针就不会了」

更准确、也更完整的说法应该是：

> Go Map在Value>128B时会自动转为指针存储，这只影响Value的GC回收，**不影响bucket数量**。Map本身不会缩容，HPA看到的内存依然不会回到初始值。唯一的根治方法是替换Map。

## **写在最后**：**这不是bug，而是trade-off**

如果你线上也遇到过：

- **连接数降了**
- **CPU 空了**
- **内存死活不下**
- **HPA 像看傻子一样盯着你**

那这大概率不是内存泄漏，而是你踩中了 **Go map + 容器调度的经典坑**。

Go的这个设计是经过权衡的：**用一定的内存浪费，换取极致的写入性能**。理解这个trade-off，才能写出既高效又"容器友好"的代码。
