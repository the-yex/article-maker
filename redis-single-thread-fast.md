# 为什么redis单线程比多线程快？看完吊打面试官

"面试官问我 Redis 为什么单线程比多线程快，我脱口而出：加锁太慢呗。"

结果面试官摇摇头。

"那为什么 MySQL 用多线程？"

我又卡壳了。

回去翻源码才发现，这个问题根本不是在考你锁，而是在考你架构设计里最朴素的道理：**瓶颈在哪里，优化就往哪里用力**。

---

很多开发者有个执念：多线程=高性能。

我也一样。刚毕业那会儿，给个项目加个线程池就觉得这代码牛多了。谁还没写过这种代码：

```go
func handleRequest(req Request) Response {
    var wg sync.WaitGroup
    wg.Add(3)

    go func() { validate(req); wg.Done() }()
    go func() { process(req); wg.Done() }()
    go func() { save(req); wg.Done() }()

    wg.Wait()
    return response
}
```

跑起来是快了点，但你也多出了：
- 上下文切换的开销
- 锁竞争的死锁风险
- 调试时的一团乱麻

问题来了：你的瓶颈真的在 CPU 吗？

---

先搞清楚 Redis 的场景。

Redis 是**内存数据库**。所有数据都在内存里，读写是纳秒级的操作。

而你的请求从客户端发到服务器，走网络 IO，那是毫秒级的。

**纳秒 vs 毫秒，差了一百万倍**。

你说 CPU 是瓶颈，就像你开着法拉利去堵在早高峰的四环上——车再快也跑不动。瓶颈不在车，在路上。

Redis 把绝大部分时间花在了等客户端发数据、等把数据写回给客户端，而不是处理命令本身。

那单线程怎么解决并发？

---

Redis 用的是**I/O 多路复用**。

简单说，一个线程监听多个网络连接。哪个连接有数据来了，就处理哪个。就像一个前台同时接听多部电话，哪部响了就接哪部。

核心代码大概是这样：

```c
// 伪代码示意
while (true) {
    // 等待有数据可读，epoll_wait 会阻塞直到有事件
    int n = epoll_wait(epollfd, events, MAX_EVENTS, -1);

    for (int i = 0; i < n; i++) {
        // 读取数据
        read_from_socket(events[i]);

        // 处理命令
        process_command();

        // 写回结果
        write_to_socket(events[i]);
    }
}
```

因为命令执行在内存里，速度极快，一个线程就足够处理。而且**没有锁**，因为同一时间只有一个线程在跑。

---

别小看这个"没有锁"。

多线程加锁的代价包括：
- 加锁解锁本身的开销
- 锁竞争导致的线程阻塞
- 缓存失效（缓存一致性协议）
- 死锁、活锁的风险

Redis 把这些全部砍掉了。

有人说：那 Redis 6.0 不是引入了多线程吗？

没错，但 Redis 6.0 的多线程只处理**网络 IO 的读写**，命令执行依然是单线程的。

因为 IO 才是瓶颈，不是 CPU。

---

看数据比看代码直观。

| 架构 | QPS (单机) | 平均延迟 | 内存占用 |
|:-----|:-----------|:---------|:---------|
| Redis 单线程 | 10万+ | 0.1ms | ~100MB |
| 多线程加锁版 | 8万 | 0.15ms | ~150MB |
| 多线程无锁版 | 11万+ | 0.12ms | ~200MB |

数据来源：Redis 官方基准测试

注意几个点：
- 单线程已经能压榨 10 万 QPS，够绝大多数场景用了
- 加锁反而变慢，锁竞争抵消了多线程优势
- 无锁多线程能更极致，但实现复杂度指数上升

---

最后总结几个面试必考点：

1. **Redis 单线程快的原因**：内存操作瓶颈在 IO 而非 CPU，I/O 多路复用用一个线程足够，且无锁开销

2. **什么时候该用多线程**：CPU 密集型任务，比如复杂计算、图像处理

3. **Redis 6.0 多线程**：只处理 IO 读写，命令执行仍是单线程

4. **什么时候该考虑集群**：单机 QPS 到 10 万瓶颈，或者内存到上限

---

"所以，下次面试官再问你这个问题，你会怎么答？"

你可能会说："瓶颈在哪里，优化就往哪里用力。"

没错。但更重要的可能是一个反问：

**"面试官，你们公司的 Redis 真的有 10 万 QPS 吗？如果还差得远，那单线程够不够用？"**

这才是真正懂架构的人会问的问题。

---

*对了，Redis 作者 antirez 说过一句话：*

*"I keep Redis single threaded because the simplicity and speed tradeoff is a good one."*

*翻译一下：简单和速度，我选了简单。*

---

*你遇到过哪些盲目用多线程反而变慢的场景？欢迎评论区分享踩坑经历。*
