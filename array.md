# Go 数组的原理与 for-range 的陷阱
在 Go 开发中，数组与切片看似简单，但在初始化、内存布局、循环遍历时常有陷阱，本篇文章带你深度剖析。

## 什么是数组（Array）

在 Go 语言中，数组是一块 **长度固定、元素类型相同、内存连续** 的数据结构,这也是go可以快速访问每个元素的原因。

```go
func main() {
	arr := [5]byte{0, 1, 2, 3, 4}
	println("arr", &arr)

	for i := range arr {
		println(i, &arr[i])
	}
}
// arr 0x1400005072b
// 0   0x1400005072b
// 1   0x1400005072c
// 2   0x1400005072d
// 3   0x1400005072e
// 4   0x1400005072f
```
![arr1](https://www.helloimg.com/i/2025/12/29/69522e330dff5.png)

可以看到：

- 数组变量 `arr` 的地址，等于第一个元素的地址

- 每个元素地址递增 1 字节（因为 这里的类型`byte` 占 1 字节）

结合我们的常识认知，**调用栈通常从高地址向低地址增长**，上图准确的展示了数组在栈中的样子。

那么，这是不是意味着我们可以通过数组的地址和元素的大小来访问数组中的任意元素哪？我们可以通过以下代码来尝试一下：

```go
func main() {
	a := [3]int{99, 100, 101}
	p := unsafe.Pointer(&a[0])

	a1 := unsafe.Pointer(uintptr(p) + 8) 
	a2 := unsafe.Pointer(uintptr(p) + 16)

	fmt.Println(*(*int)(p))  // 99
	fmt.Println(*(*int)(a1)) // 100
	fmt.Println(*(*int)(a2)) // 101
}
// Output:
// 99
// 100
// 101
```
![arr2](https://www.helloimg.com/i/2025/12/29/695238462bee7.png)

这个示例说明：

- 数组的每个元素紧密排列
- Go 编译器严格按照类型大小进行地址计算(**`数组起始地址 + 索引 × 元素大小`** )

⚠️ `unsafe` 仅用于理解内存模型，**不要在业务代码中这样写**。

---

在 Go 中，数组的 **长度属于类型定义的一部分**。

```go
func main() {
	a := [5]byte{}
	b := [4]byte{}

	fmt.Printf("%T\n", a) // [5]uint8
	fmt.Printf("%T\n", b) // [4]uint8
}
```
尽管`a`、`b` 都是字节数组，但是Go编译器认为他们是完全不同的类型，`%T` 格式打印可以清楚的体现这一点。
这意味着：

- `[5]byte` 和 `[4]byte` 是 **完全不同的类型**
- 不能相互赋值，也不能作为同一个参数类型使用

这也是 Go 中数组不如切片常用的重要原因之一。

---

## 数组的初始化方式

Go 支持多种数组初始化写法：

```go
var arr1 [10]int                // 全部初始化为 0

arr2 := [...]int{1, 2, 3, 4, 5} // 自动推导长度
arr3 := [...]int{11: 3}         // 索引 11 位置赋值，其余为 0
arr4 := [5]int{1, 4: 5}         // 指定索引初始化
arr5 := [5]int{2: 3, 4, 4: 5}   // 混合写法
```

这里有一个有意思的情况：当我们创建一个元素少于4个的数组时，Go会生成指令，将值一个一个放入数组中。

所以当我们编写 `arr:=[4]int{1,2,3,4}`这样的代码时,实际上执行的逻辑是：

``````go
arr := [4]int{}
arr[0] = 1
arr[1] = 2
arr[2] = 3
arr[3] = 4
``````

这种策略称为**`本地代码初始化(LocalCode initialization)`**：初始化代码是在**某个具体函数的作用域内生成并执行的**，而不是作为全局或静态初始化代码的一部分。

当数组元素超过4个，编译器会创建数组的一个静态表示，这种方式称为 `静态初始化（static initialization）`

我们来看看`[5]int{1,2,3,4,5}` 在 Go 汇编层面长什么样

``````
main..stmp_1 SRODATA static size=40
	0x0000 01 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00  ................
	0x0010 03 00 00 00 00 00 00 00 04 00 00 00 00 00 00 00  ................
	0x0020 05 00 00 00 00 00 00 00                          ........
``````

可以看到，数组的数据被存放在 stmp_1 中，这是一个 **只读的静态数据段**，总大小为 **40 字节**（每个元素 8 字节）。
同时，这块静态数据的地址是 **在编译期就被硬编码进二进制文件中的**。

这意味着：

- 数组中各个元素的值会被存储在二进制文件的 **只读数据段（read-only section）** 中
- 这些静态数据在 **编译期就已经生成**
- 数组的初始值会被 **直接嵌入到可执行文件里**，而不是在运行时逐个赋值

在讨论数组的定义和初始化时，还需要特别说明的一点是**`并不是所有数组都会分配在栈上`**，如果变量本身太大，就会被分配到堆上。

``````go
	// MaxStackVarSize is the maximum size variable which we will allocate on the stack.
	// This limit is for explicit variable declarations like "var x T" or "x := ...".
	// Note: the flag smallframes can update this value.
	MaxStackVarSize = int64(10 * 1024 * 1024)
``````
![arr4](https://www.helloimg.com/i/2025/12/29/6952406c3db80.png)

源码分析：如果某个变量(不仅是数组)的大小超过阈值`MaxStackVarSize` ,那么它就会被认为不适合进行栈分配，进而逃逸到堆上。



---

## len 与 cap

数组没有单独的容量概念：

```go
func main() {
	a := [5]int{1, 2, 3}
	println(len(a)) // 5
	println(cap(a)) // 5
}
```

原因是：

- 数组长度在编译期就已经确定
- `len` 和 `cap` 都会被编译器直接替换为常量

---

## 数组与切片的关系

切片(slicing)是一种从数组中获取切片的方式，完整形式使用如下语法表示：**`[start:end:capacity]`**

其中：
- start 表示新切片中 **第一个包含的元素索引**（包含该索引）
- end 表示新切片中 **最后一个不包含的元素索引**（不包含该索引）
- capacity 是一个可选参数，用于指定新切片的容量



在实际代码中，你更常见到的是它的简写形式：

```go
func main() {
    a := [5]int{0, 1, 2, 3, 4}

    // new slice from a[1] to a[3-1]
    b := a[1:3]  // [1 2]

    // new slice from a[0] to a[3-1]
    c := a[:3] // [0 1 2]

    // new slice from a[1] to a[5-1]
    d := a[1:] // [1 2 3 4]
}
```
![arr5](https://www.helloimg.com/i/2025/12/29/695242ba8c76d.png)

如果切片表达式中省略了某些索引，它们会使用默认值：
- start 默认为 0
- end 默认为原始切片或数组的 **长度**
- capacity 默认为原始切片的 **容量**，或者原始数组的 **长度**

新切片的长度和容量计算如下：

- **新切片的长度（len）** = end - start

- **新切片的容量（cap）** =
  
  - 如果显式指定了 capacity，则为 capacity - start
  - 否则为 原始容量 - start
  
  

当我们写下：`b := a[1:3]`,实际上发生的是：

``````go
b.array = &a[1]
b.len = 3-1
b.cap = 5-1
``````

关于当我们指定的 end 索引越界时为什么会触发 panic：
这是因为 **end 是一个“不包含”的边界（exclusive）**，因此它**可以被指定为等于原始数组的长度**。
也就是说，下面这种写法是合法的：

``````go
a[len(a):]
``````

但一旦 end **大于数组或切片的长度**，就会在运行时触发 panic。

那我们能不能把 start 指定为 5，比如写成 a[5:] 呢？

``````go
func main() {
    a := [5]int{1, 2, 3, 4, 5}
    b := a[5:] // []
}
``````

这可能会让人感到意外，答案是 **可以**。
实际上，我们创建的是一个 **空切片（empty slice）**，它的长度和容量都是 0 (go 对这种情况有特殊处理规则)。



---

## 数组是值类型

数组在 Go 中是 **值类型**，函数传参会发生完整拷贝。

```go

func modify(a [5]byte) {
	a[0] = 1
}

func main() {
	a := [5]byte{}
	modify(a)
	fmt.Println(a)
}

// [0 0 0 0 0]
```

输出结果是意料之中的，因为我们修改的是 **数组的拷贝**，而不是原数组。

> “这不会很低效吗？每次都要拷贝数组。”

只有在 **把大数组传给函数** 并且 **基准测试或性能分析显示这是瓶颈** 时，才会显得低效。

否则，像平时那样传递数组就可以了。

```go
func modify(a *[5]byte) {
	a[0] = 1
}
```

---

下面是一个 **数组循环中的小陷阱**，尤其是使用 for-range 循环时。

我们先来看一个快速示例：

```go
func main() {
	a := [3]int{1, 2, 3}
	b := [3]int{4, 5, 6}

	for i, v := range a {
		if i == 1 {
			a = b
		}
		fmt.Println(v)
	}
}
```

你可能会以为输出是：

```
1
5
6
```

但实际输出却是：

```
1
2
3
```

### 原因是什么？

**因为 `range` 在遍历数组时，会先拷贝一份数组副本，然后遍历副本。**

也就是说：

- `range a` 时，`a` 已经被复制
- 循环过程中修改原数组，不会影响遍历结果

### 如何避免这个问题？

对数组指针进行 `range`：

```go
for i, v := range &a {
	fmt.Println(v)
}
```

此时遍历的是 **原数组本身**，不会发生隐式拷贝。

**Go 支持对数组的 for-range 使用指针**，而 **对切片则不支持指针形式**。

---

## 总结

- Go 数组是 **连续内存 + 固定长度** 的数据结构
- 数组长度是类型的一部分
- 数组是值类型，传参和 `range` 都会发生拷贝
- `for-range` 遍历数组时存在非常隐蔽的坑

在实际工程中：

> **除非你非常明确地需要数组语义，否则优先使用切片（slice）**

