
> 一直计划试一试新发布的golang 1.26不稳定版本，今天终于安排上了
>
> 于是先安装玩了一下新的特性(以下内容我们不深挖原理，只聊能给我们普通开发人员带来什么)

![](https://www.helloimg.com/i/2026/01/23/69730d8051c22.png)

这个版本最大的亮点莫过于 **Green Tea GC（绿茶垃圾回收器）正式成为默认的垃圾回收器**。

这意味着:**升级到 Go 1.26，你的程序 GC 开销可能降低 10%-40%。**

---

## **为什么 Go 要换 GC？**

老版本 GC 用的是**并行三色标记-清除**，长期存在几个硬伤

GC 标记阶段需要遍历堆中的对象指针，寻找哪些对象还"活着",问题是：
- **对象在内存里东一个西一个**
- **指针跳来跳去，毫无规律**

这就导致：

| 问题 | 后果 |
|------|------|
| CPU 缓存频繁失效 | 明明有高速缓存，却总是用不上 |
| 内存访问不连续 | 每次都要等主内存，慢 100 倍 |
| CPU 预测失败 | 现代 CPU 的"提前准备"功能完全废了 |

### 这到底有多严重？

- 有些程序 **20% 甚至更多的 CPU 时间花在 GC 上**
- 其中约 **35% 是在干等——等内存数据送过来**
- 随着 CPU 核心越来越多，这个问题只会更严重

> 之前我一直跟同事说"等两年硬件升级，程序说不定会自动变快"。但对 GC 来说，可能是反的——硬件越新，GC 相对越慢。

---

## Green Tea GC 做了什么？

核心改变就一句话：

> **不再一个一个扫描对象，而是一整页一整页地扫描。**

看到这里，很多人脑子里已经开始冒出一个疑问：
> 既然 Green Tea 是“按页扫描”，
> 那还怎么从根对象一路标记到子对象、孙对象？
> 子对象明明可能在别的内存页上啊？

这是一个**非常正常、也非常关键的问题**。

先说结论：

> **Green Tea GC 并没有改变 Go 的可达性规则，**
> **变的只是“扫描内存的方式”，不是沿“对象之间的关系”。**

### **老 GC：对象级扫描（指针一多就乱跳）**

老版本 GC 的工作方式，本质是**以对象为单位推进的**：

``````
取出一个对象
→ 扫描它的字段
→ 发现一个指针
→ 立刻跳到指向的对象
``````

如果对象之间的引用关系是这样的：

``````
对象A（页1）
  → 对象B（页7）
    → 对象C（页2）
      → 对象D（页9）
``````
CPU 实际访问内存的顺序就会变成：
```
页1 → 页7 → 页2 → 页9 → 页1 → 页8 ...
```
结果就是：
	•	CPU cache 一直失效
	•	内存预取完全帮不上忙
	•	大量时间花在“等内存”上

### **Green Tea GC：页级组织，对象级语义**

Green Tea GC 做的不是“少扫对象”，而是：

> **把扫描调度单位，从“对象”升级成了“页”。**

但要注意一个非常重要的点：

> **对象之间的引用关系，完全没变。**

它只是把流程改成了：

``````
这一页里的对象，先顺序扫完
发现跨页引用？记下来
等轮到那个页，再一起扫
``````

换句话说：

- **“谁引用谁”没变**
- **“什么时候去访问那块内存”变了**

## **那根对象 → 子对象是怎么处理的？**

我们用一个最直观的例子来看。

### **场景：跨页引用**

``````
Page A:
  RootObj
    └── ptr → ChildObj

Page B:
  ChildObj
``````

### **Green Tea GC 的真实流程是：**

#### **① 扫 Root（和以前一样）**

- RootObj 被发现
- RootObj 所在的 **Page A 被加入扫描队列**

#### **② 扫 Page A（关键变化）**

- 顺序扫描 Page A 中的所有对象
- 扫到 RootObj 时，发现它指向 ChildObj
- **ChildObj 会被标记为“可达”**

⚠️ 但这里有个关键差异：

> **不会立刻跳到 Page B 去扫描 ChildObj**

而是：

- 把 **Page B 标记为“后续需要扫描”**
- 继续把 Page A 剩下的对象一次扫完

#### **③ 扫 Page B（稍后、批量）**

- 轮到 Page B
- 顺序扫描 Page B 中的所有对象
- 包括刚才被 RootObj 引用到的 ChildObj


### 这样做的好处是

| 改进 | 对我们的程序有啥影响？ |
|------|------------------------|
| 内存访问更规整 | 程序响应更稳定，毛刺少 |
| 缓存命中率高 | 相同硬件，CPU空闲时间更少,GC 更快完成 |
| 可以用向量指令加速 | x86服务器收益更明显 |
| 工作队列更小 | 多核扩展性更好 |

打个比方：
- 以前的 GC 像**在城市里开出租**，红绿灯一个接一个，到处绕路
- Green Tea 像**上了高速公路**，一脚油门跑到底

---

## 实测：Go 1.25 vs Go 1.26

说了这么多理论，用数据说话才符合我们的身份，我简单写了一个能产生 GC 压力的 HTTP 服务进行压测。

### 测试环境

- **硬件**: MacBook Pro (Apple Silicon)
- **压测工具**: gocannon
- **并发连接**: 100
- **持续时间**: 30 秒
- **Go 版本**: 1.25.0 vs 1.26.0-rc2

### 测试代码

```go
// 模拟复杂对象图结构
type Object struct {
    Data     []byte
    Children []*Object  // 递归引用，形成复杂对象图
}

// 创建对象图，增加 GC 压力
func createObjectGraph(depth int) *Object {
    if depth <= 0 { return nil }
    obj := &Object{Data: make([]byte, 256+rand.Intn(512))}
    for i := 0; i < rand.Intn(3)+1; i++ {
        obj.Children = append(obj.Children, createObjectGraph(depth-1))
    }
    return obj
}
```
### 压测结果

| 指标 | Go 1.25 | Go 1.26 | 变化 |
|------|---------|---------|------|
| 请求总数 | 1,867,349 | 1,723,172 | -7.7% |
| 平均延迟 | 1.61ms | 1.74ms | +8.4% |
| **GC 次数** | **3,973** | **3,166** | **-20.3%** |
| 内存分配 | 90.0 GB | 83.1 GB | -7.7% |

**关键发现：GC 次数减少了 20.3%！**
虽然吞吐量有波动（受测试环境影响），但关键指标是：

> **GC 次数减少了 20%！**

这意味着：
- 程序花在 GC 上的 CPU 时间更少
- 留给业务逻辑的资源更多
- 在生产环境中，这可能转化为实实在在的成本节约

> ⚠️ 本次测试在 Mac ARM 芯片上进行，无法使用 AVX-512 向量加速。在 x86 服务器上，收益会更明显。

---

## 怎么用？

### Go 1.26（即将发布）
```bash
# 默认就是 Green Tea GC，直接用
go build

# 如果想退回旧 GC（不建议）
GOEXPERIMENT=nogreenteagc go build
```

### **Go 1.25 想尝鲜 Green Tea GC**

```bash
GOEXPERIMENT=greenteagc go build
```

**不需要改代码，重新编译就行。**

---

## 哪些情况收益不大？

1. **GC 压力本来就小的程序** - 没什么好优化的
2. **对象图很稀疏** - 每页只有一两个对象
3. **ARM 架构** - 暂时没有向量加速加成

> 换句话说，Green Tea 不是银弹，但在 GC 压力大、对象集中、多核 x86 服务器上，收益立竿见影。

---

## 总结

 升级到 Go 1.26 你可能得到

- 免费的 GC 性能提升（10%-40%） 
- 更稳定的响应时间 
- 对多核/大内存场景更友好 
- 不用改代码，重新编译即可 

**如果你在跑 Go 服务，建议 Go 1.26 正式版发布后第一时间跑压测对比一下是否能有效提升，再考虑是否需要升级。**