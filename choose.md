# 我在 18 个项目里踩过的数据库选型坑：这 8 个最常见，别再中招了

这几年帮朋友看架构方案，我有一个越来越清晰的感受：

> **很多系统不是写崩的，是在“选数据库”那一步就已经走歪了。**

你大概率见过这些场面：

- 日活几百的小系统，一上来就 MongoDB + Elasticsearch  
- 明明是做报表统计，却硬着头皮 MySQL 分库分表  
- 一个简单缓存，还要 Redis + Memcached 双集群  

当年我也干过这种事，说白了就是一句话：**看起来高级。**

但系统真跑起来之后才发现，
复杂度、维护成本、排障难度，全都翻倍。

下面这 8 个场景，基本是普通后端最容易遇到的坑。  
如果你正准备做选型，先看完，真的能少走不少弯路。

---

## 1️⃣ 实时分析场景：别再迷信 Snowflake / Redshift

我第一次被 OLAP 折磨，是在一个用户行为分析项目上。  
当时选型很“国际化”：Snowflake + BI 工具。

上线之后才发现：

- 一个 group by 查询，经常 20～30 秒  
- 产品天天问我：是不是 SQL 写得有问题  

后来实在扛不住了，换成 ClickHouse。  
说实话，当时也只是想试试。

结果第一条查询出来的时候，我盯着屏幕愣了两秒：

**2 秒。**

那一刻我才反应过来：  
不是我不会写 SQL，是一开始库就选错了。

👉 更合适的选择：**ClickHouse**  
适合：用户行为分析、实时报表、广告效果统计  

⚠️ 注意：  
ClickHouse 不适合高频更新场景，别把它当 MySQL 用。

---

## 2️⃣ 文档 + 搜索：MongoDB + ES 是经典误区

很多内容系统一开始都是这个组合：

> MongoDB 存文章  
> Elasticsearch 做搜索  

听起来很合理，用起来很痛苦：

- 数据同步经常延迟  
- 两边数据对不上  
- 出问题很难判断是 Mongo 的锅还是 ES 的锅  

后来我们干脆全换成 PostgreSQL：

- JSONB 存内容结构  
- 内置全文检索  
- 一个库解决问题  

现在回头看才意识到：

> **两套系统 ≠ 更专业  
> 两套系统 = 两倍运维成本**

---

## 3️⃣ 本地数据分析：pandas + SQLite 很容易翻车

用 pandas 处理 CSV 很爽，  
直到你数据一上百万行：

- 内存直接爆  
- 查询慢得怀疑人生  
- 代码开始变成各种临时补丁  

后来换成 DuckDB：

- 直接用 SQL 查 CSV / Parquet  
- 不用先导入  
- 速度肉眼可见地快  

现在我本地分析基本都是：

> DuckDB + SQL  
> pandas 只负责画图

---

## 4️⃣ 日志系统：ELK 真的太重了

ELK 的问题不是不好用，而是：

- 分片多了之后管理很烦  
- 存储成本越来越高  
- 维护日志系统本身就成了一份工作  

后来我们换成 VictoriaLogs，  
最大的感受只有一句话：

> 终于不用天天盯 ES 集群了。

存储成本也大概砍掉了一半多。  
如果你只是存日志，而不是做复杂全文搜索，
真的没必要一上来就 ELK。

---

## 5️⃣ 监控指标：Prometheus + Thanos 太折腾

Prometheus 很好用，但也有硬伤：

- 本地只能存十几天  
- 想存久一点，就得上 Thanos  
- 架构立刻复杂一层  

后来换成 VictoriaMetrics：

- 单机就能存一年  
- 查询方式差不多  
- 运维简单很多  

那之后我对监控系统的理解变成：

> **稳定第一，优雅第二。**

---

## 6️⃣ 时序数据：InfluxDB 的“贵”是慢慢显现的

InfluxDB 写入很快，但问题是：

- 存储成本高  
- 复杂聚合不好写  
- rollup 经常要自己实现  

后来换成 TimescaleDB：

- 表还是 PostgreSQL  
- 查询还是 SQL  
- 聚合也能直接写  

最大的好处是：  
不用再额外维护一套时序体系。

---

## 7️⃣ 缓存：Redis + Memcached 纯属自我感动

我见过不少系统是这样：

> Redis 当主缓存  
> Memcached 当二级缓存  

问为什么这么设计，回答一般是：  
“看起来比较稳。”

后来我们换成 Dragonfly：

- 兼容 Redis 协议  
- 同样内存能放更多数据  
- 架构还更简单  

这时候才意识到：

> **缓存的关键是命中率，不是组件数量。**

---

## 8️⃣ 分布式 SQL：别再自己折腾分库分表了

MySQL 分库分表 + 中间件，常见结局是：

- SQL 受限制  
- 扩容很麻烦  
- 出问题排三层  

后来换成 TiDB：

- 业务代码基本不用管分片  
- 扩容对应用透明  

代价当然有：

- 延迟比 MySQL 高一点  
- 成本也更高  

但对中大型系统来说，
这点代价换稳定，往往是划算的。

---

# 下面这些不是人人都会遇到，只给结论

这些更多是特定场景才会碰到，了解一下就行：

- 服务协调：ZooKeeper / Consul → **etcd**  
- 搜索引擎：Elasticsearch → **Meilisearch（轻量场景）**  
- 向量数据库：Milvus / Pinecone → **Qdrant**  
- 图数据库：Neo4j → **Memgraph**  
- 宽列存储：Cassandra → **ScyllaDB**  
- 大数据列存：HBase + Hadoop → **Bigtable（托管场景）**  
- 嵌入式 KV：RocksDB → **BadgerDB（Go 更友好）**  
- 消息队列：Kafka + ZooKeeper → **Redpanda**  
- 分布式查询：Spark / Presto → **Trino**  
- 调度系统元数据：Airflow + MySQL → **PostgreSQL**  

---

## 最后说句掏心窝子的

这 18 个项目走下来，我给自己定了三条选型原则：

> 能单体，就别分布式  
> 能一套系统解决，就别两套  
> 架构复杂度，本身就是技术债  

很多人以为：

> 性能问题靠调优  
> 架构问题靠中间件  

但真实情况往往是：

> **大部分性能问题，本质是选型问题  
> 大部分复杂度，来自过度设计**

如果你最近正在做架构调整，
或者准备新项目选型，
希望这篇能帮你少踩几个坑。

如果你也有类似的踩坑经历，
欢迎在评论区说说你的故事。
